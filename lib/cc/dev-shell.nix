# CC-specific Flazel development shell
#
# Wraps the core mkFlazelDevShell with C/C++ toolchain packages.
# Supports multiple toolchains for cross-compilation.
#
# Usage:
#   hostCfg = flazel.lib.cc.mkConfig { toolchainName = "host"; ... };
#   mips64Cfg = flazel.lib.cc.mkConfig { toolchainName = "mips64"; ... };
#   shell = flazel.lib.cc.mkDevShell {
#     inherit pkgs caches;
#     toolchains = {
#       host = hostCfg;
#       mips64 = mips64Cfg;
#     };
#   };
#
{
  pkgs,
  # Attrset of { name = cfg; } for each toolchain
  toolchains,
  caches,
  # Bazel package to use (defaults to latest stable)
  bazel ? pkgs.bazel,
  # Path to flazel source (for bzlmod local_path_override)
  flazelPath ? null,
  extraPackages ? [ ],
  shellHook ? "",
}:
let
  coreDevShell = import ../core/dev-shell.nix;

  # Get list of toolchain configs
  toolchainList = pkgs.lib.attrValues toolchains;
  toolchainNames = pkgs.lib.attrNames toolchains;

  # Use the first toolchain for PATH packages (gcc, binutils)
  # All toolchains should have compatible host tools
  primaryCfg = builtins.head toolchainList;

  # CC-specific setup: symlink toolchains and libs
  ccDepsSetup = ''
        mkdir -p .nix-bazel-deps/toolchains .nix-bazel-deps/libs

        # Symlink each toolchain
        ${pkgs.lib.concatStringsSep "\n" (
          pkgs.lib.mapAttrsToList (name: cfg: ''
            ln -s ${cfg.bazelNixDeps}/toolchains/${name} .nix-bazel-deps/toolchains/${name}
          '') toolchains
        )}

        # Merge libs from all toolchains (each bazelNixDeps already has both
        # suffixed and unsuffixed symlinks, e.g., boost and boost_default)
        ${pkgs.lib.concatStringsSep "\n" (
          pkgs.lib.mapAttrsToList (name: cfg: ''
            for lib in ${cfg.bazelNixDeps}/libs/*; do
              libname=$(basename "$lib")
              # Use -f to allow later toolchains to override (e.g., default wins for unsuffixed)
              ln -sf "$lib" ".nix-bazel-deps/libs/$libname"
            done
          '') toolchains
        )}

        # Generate .bazelrc.nix with toolchain registrations for this shell
        # Placed inside .nix-bazel-deps/ so it's regenerated when the directory is recreated
        cat > .nix-bazel-deps/.bazelrc.nix << 'EOF'
    # Auto-generated by nix develop - DO NOT EDIT
    # This file registers CC toolchains available in the current shell
    ${
      pkgs.lib.concatMapStrings (name: ''
        build --extra_toolchains=@local_config_cc_${name}//:cc_toolchain
      '') toolchainNames
    }EOF

        # Write marker file with available toolchains (forces module extension re-evaluation)
        # The nix_cc module extension reads this file to detect when toolchains change
        echo "${pkgs.lib.concatStringsSep "," (builtins.sort builtins.lessThan toolchainNames)}" > .nix-bazel-deps/.toolchain-marker
  '';

  # Generate toolchain info for shell hook
  toolchainInfo = pkgs.lib.concatStringsSep ", " (
    pkgs.lib.mapAttrsToList (
      name: cfg: "${name} (${if cfg.static then "static" else "dynamic"})"
    ) toolchains
  );
in
coreDevShell {
  inherit
    pkgs
    caches
    bazel
    flazelPath
    ;

  extraDepsSetup = ccDepsSetup;

  packages = [
    primaryCfg.gcc
    primaryCfg.binutils
  ]
  ++ extraPackages;

  shellHook = ''
    echo "(CC toolchains: ${toolchainInfo})"
    echo "  Use --platforms=@local_config_cc_<name>//:platform to select"
    ${shellHook}
  '';
}
