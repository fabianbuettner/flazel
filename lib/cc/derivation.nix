# CC-specific Flazel derivation builder
#
# Wraps the core mkFlazelDerivation with C/C++ toolchain configuration.
#
# Usage:
#   cfg = flazel.lib.cc.mkConfig { toolchainName = "default"; ... };
#   build = flazel.lib.cc.mkDerivation {
#     inherit pkgs cfg caches;
#     name = "my-project";
#     src = ./.;
#     bazelCommand = "build --config=nix //...";
#     installPhase = "cp -rL bazel-bin/* $out/";
#   };
#
{
  pkgs,
  name,
  cfg,
  caches,
  src,
  bazelCommand,
  installPhase,
  # Bazel package to use (defaults to latest stable)
  bazel ? pkgs.bazel,
  # Path to flazel source (for bzlmod local_path_override)
  flazelPath ? null,
  extraNativeBuildInputs ? [ ],
  extraBuildInputs ? [ ],
}:
let
  coreDeriv = import ../core/derivation.nix;

  # CC-specific setup: symlink toolchain and libs
  # Uses new directory structure: toolchains/<name>/cc, toolchains/<name>/deps
  ccDepsSetup = ''
    mkdir -p .nix-bazel-deps/toolchains
    ln -s ${cfg.bazelNixDeps}/toolchains/${cfg.toolchainName} .nix-bazel-deps/toolchains/${cfg.toolchainName}
    ln -s ${cfg.bazelNixDeps}/libs .nix-bazel-deps/libs

    # Write marker file (must match dev-shell.nix for lockfile consistency)
    echo "${cfg.toolchainName}" > .nix-bazel-deps/.toolchain-marker

    # Generate .bazelrc.nix with toolchain registration (must match dev-shell.nix)
    cat > .nix-bazel-deps/.bazelrc.nix << 'BAZELRC'
# Auto-generated by nix build - DO NOT EDIT
build --extra_toolchains=@local_config_cc_${cfg.toolchainName}//:cc_toolchain
BAZELRC
  '';
in
coreDeriv.mkFlazelDerivation {
  inherit
    pkgs
    name
    src
    caches
    bazel
    flazelPath
    bazelCommand
    installPhase
    ;

  extraDepsSetup = ccDepsSetup;

  nativeBuildInputs = [
    cfg.gcc
    cfg.binutils
  ]
  ++ pkgs.lib.optional (!cfg.static) pkgs.autoPatchelfHook
  ++ extraNativeBuildInputs;

  buildInputs = [
    cfg.libc
    cfg.libcDev
    cfg.gcc.cc
  ]
  ++ (if cfg.static then [ ] else builtins.attrValues cfg.nixpkgsLibs)
  ++ extraBuildInputs;

  runtimeDependencies =
    if cfg.static then [ ] else map (pkg: pkg.out or pkg) (builtins.attrValues cfg.nixpkgsLibs);
}
